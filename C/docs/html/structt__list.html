<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Calculadora: t_list Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Calculadora
   </div>
   <div id="projectbrief">cara, faz umas contas aí.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="structt__list-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">t_list Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.  
 <a href="structt__list.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="list_8h_source.html">list.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae82e5862bbd9ab16a295cd42f7e126c0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structt__list.html">t_list</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a></td></tr>
<tr class="memdesc:ae82e5862bbd9ab16a295cd42f7e126c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Definição de t_stack. Tem compatibilidade com <a class="el" href="structt__list.html" title="Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.">t_list</a>.  <a href="#ae82e5862bbd9ab16a295cd42f7e126c0">More...</a><br /></td></tr>
<tr class="separator:ae82e5862bbd9ab16a295cd42f7e126c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae0e6488e8c26845bc3ab83a51a20700c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__node.html">t_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ae0e6488e8c26845bc3ab83a51a20700c">create_node</a> (void *data)</td></tr>
<tr class="memdesc:ae0e6488e8c26845bc3ab83a51a20700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cria um nó dinamicamente. Normalmente, essa função não é chamada diretamente. É chamada por funções como <a class="el" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1" title="Insere um item no começo da lista.">insert_head()</a> e <a class="el" href="structt__list.html#a87f65f2ab34ec73a894eab5055eb3173" title="Adiciona um nó ao topo da pilha.">push()</a>. Pode ser considerada uma função privada.  <a href="#ae0e6488e8c26845bc3ab83a51a20700c">More...</a><br /></td></tr>
<tr class="separator:ae0e6488e8c26845bc3ab83a51a20700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d94b3a49834ca1a8077d5b98214fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__list.html">t_list</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec">create_list</a> (const char *data_type)</td></tr>
<tr class="memdesc:aa7d94b3a49834ca1a8077d5b98214fec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cria dinamicamente uma lista.  <a href="#aa7d94b3a49834ca1a8077d5b98214fec">More...</a><br /></td></tr>
<tr class="separator:aa7d94b3a49834ca1a8077d5b98214fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2701392584bad966b3ef9afe041bc31"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#aa2701392584bad966b3ef9afe041bc31">get_head</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:aa2701392584bad966b3ef9afe041bc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna o dado apontado pelo primeiro item da lista. Retorna <code>NULL</code> se a lista estiver vazia.  <a href="#aa2701392584bad966b3ef9afe041bc31">More...</a><br /></td></tr>
<tr class="separator:aa2701392584bad966b3ef9afe041bc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad083a2ef6a0be599573a1b89a650d7a9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ad083a2ef6a0be599573a1b89a650d7a9">get_tail</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:ad083a2ef6a0be599573a1b89a650d7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna o dado apontado pelo último item da lista. Retorna <code>NULL</code> se a lista estiver vazia.  <a href="#ad083a2ef6a0be599573a1b89a650d7a9">More...</a><br /></td></tr>
<tr class="separator:ad083a2ef6a0be599573a1b89a650d7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d94767507f4903296df2a3ff20e834"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ab3d94767507f4903296df2a3ff20e834">is_empty</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:ab3d94767507f4903296df2a3ff20e834"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checa se a lista está vazia. É o caso de uma lista que acabou de ser criada.  <a href="#ab3d94767507f4903296df2a3ff20e834">More...</a><br /></td></tr>
<tr class="separator:ab3d94767507f4903296df2a3ff20e834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0f16dda83dde274b1604e8fe5b5c17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17">print</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a0d0f16dda83dde274b1604e8fe5b5c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dados da lista.  <a href="#a0d0f16dda83dde274b1604e8fe5b5c17">More...</a><br /></td></tr>
<tr class="separator:a0d0f16dda83dde274b1604e8fe5b5c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0baf4f69baccf00c66d517c87aeea006"><td class="memItemLeft" align="right" valign="top"><a id="a0baf4f69baccf00c66d517c87aeea006"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a0baf4f69baccf00c66d517c87aeea006">compare</a> ()</td></tr>
<tr class="memdesc:a0baf4f69baccf00c66d517c87aeea006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Não tá pronta. Não Preciso por agora. <br /></td></tr>
<tr class="separator:a0baf4f69baccf00c66d517c87aeea006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc16ed006377d2eb4cd5a7cba829fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a> (<a class="el" href="structt__list.html">t_list</a> *list, void *data)</td></tr>
<tr class="memdesc:a7bc16ed006377d2eb4cd5a7cba829fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insere um item no começo da lista.  <a href="#a7bc16ed006377d2eb4cd5a7cba829fc1">More...</a><br /></td></tr>
<tr class="separator:a7bc16ed006377d2eb4cd5a7cba829fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb8ee7eb28d4b70fd3e61177d6e95b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#aadb8ee7eb28d4b70fd3e61177d6e95b2">insert_tail</a> (<a class="el" href="structt__list.html">t_list</a> *list, void *data)</td></tr>
<tr class="memdesc:aadb8ee7eb28d4b70fd3e61177d6e95b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insere um item no final da lista.  <a href="#aadb8ee7eb28d4b70fd3e61177d6e95b2">More...</a><br /></td></tr>
<tr class="separator:aadb8ee7eb28d4b70fd3e61177d6e95b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002043e4f5f58844e2fafa135691a2e2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a002043e4f5f58844e2fafa135691a2e2">remove_head</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a002043e4f5f58844e2fafa135691a2e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove o primeiro nó da lista e retorna seu dado e libera a memória apontada pelo nó.  <a href="#a002043e4f5f58844e2fafa135691a2e2">More...</a><br /></td></tr>
<tr class="separator:a002043e4f5f58844e2fafa135691a2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2856474aa1a64f60a649cc55d84e5633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a2856474aa1a64f60a649cc55d84e5633">delete_head</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a2856474aa1a64f60a649cc55d84e5633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove o primeiro nó da lista e libera o espaço de memória apontado por <code>data</code> desse nó.  <a href="#a2856474aa1a64f60a649cc55d84e5633">More...</a><br /></td></tr>
<tr class="separator:a2856474aa1a64f60a649cc55d84e5633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf788835199c3cc0faeee83d1a5174f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#adf788835199c3cc0faeee83d1a5174f0">clear</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:adf788835199c3cc0faeee83d1a5174f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limpa a lista cujos ponteiros para dado <b>apontam</b> para espaços alocados dinamicamente.  <a href="#adf788835199c3cc0faeee83d1a5174f0">More...</a><br /></td></tr>
<tr class="separator:adf788835199c3cc0faeee83d1a5174f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78961805bdb4393433523317d8163e20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a78961805bdb4393433523317d8163e20">soft_clear</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a78961805bdb4393433523317d8163e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limpa a lista cujos ponteiros para dado <b>não</b> apontam para espaços alocados dinamicamente.  <a href="#a78961805bdb4393433523317d8163e20">More...</a><br /></td></tr>
<tr class="separator:a78961805bdb4393433523317d8163e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11162c6d4ab7eb4745884d7556e64bfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a11162c6d4ab7eb4745884d7556e64bfa">print_int_list</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a11162c6d4ab7eb4745884d7556e64bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>int</code>. Pode ser considerada uma função privada.  <a href="#a11162c6d4ab7eb4745884d7556e64bfa">More...</a><br /></td></tr>
<tr class="separator:a11162c6d4ab7eb4745884d7556e64bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda523ec926b71f0c0ffc6811c0c84d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#acda523ec926b71f0c0ffc6811c0c84d1">print_double_list</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:acda523ec926b71f0c0ffc6811c0c84d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>double</code>. Pode ser considerada uma função privada.  <a href="#acda523ec926b71f0c0ffc6811c0c84d1">More...</a><br /></td></tr>
<tr class="separator:acda523ec926b71f0c0ffc6811c0c84d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b79392e3a1156b0c077dd6749c19cfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a7b79392e3a1156b0c077dd6749c19cfd">print_str_list</a> (<a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="memdesc:a7b79392e3a1156b0c077dd6749c19cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>char*</code> (ou "<code>string</code>"). Pode ser considerada uma função privada.  <a href="#a7b79392e3a1156b0c077dd6749c19cfd">More...</a><br /></td></tr>
<tr class="separator:a7b79392e3a1156b0c077dd6749c19cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f65f2ab34ec73a894eab5055eb3173"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a87f65f2ab34ec73a894eab5055eb3173">push</a> (<a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *stack, void *data)</td></tr>
<tr class="memdesc:a87f65f2ab34ec73a894eab5055eb3173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adiciona um nó ao topo da pilha.  <a href="#a87f65f2ab34ec73a894eab5055eb3173">More...</a><br /></td></tr>
<tr class="separator:a87f65f2ab34ec73a894eab5055eb3173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3691daad22cb3718822a88ac465ca3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a1d3691daad22cb3718822a88ac465ca3">pop</a> (<a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *stack)</td></tr>
<tr class="memdesc:a1d3691daad22cb3718822a88ac465ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove da pilha o nó no topo da pilha e libera o espaço de memória apontado pelo dado do nó.  <a href="#a1d3691daad22cb3718822a88ac465ca3">More...</a><br /></td></tr>
<tr class="separator:a1d3691daad22cb3718822a88ac465ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c7cffd8032adc9fbe65be10d8a7e61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ac3c7cffd8032adc9fbe65be10d8a7e61">soft_pop</a> (<a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *stack)</td></tr>
<tr class="memdesc:ac3c7cffd8032adc9fbe65be10d8a7e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove o nó do topo da pilha.  <a href="#ac3c7cffd8032adc9fbe65be10d8a7e61">More...</a><br /></td></tr>
<tr class="separator:ac3c7cffd8032adc9fbe65be10d8a7e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acc94726e85208a909776323a41e380"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a6acc94726e85208a909776323a41e380">peek</a> (<a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *stack)</td></tr>
<tr class="memdesc:a6acc94726e85208a909776323a41e380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retorna o ponteiro para o dado do nó no topo da pilha.  <a href="#a6acc94726e85208a909776323a41e380">More...</a><br /></td></tr>
<tr class="separator:a6acc94726e85208a909776323a41e380"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad890ffb53338be5bb6c68b3b9937dbcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__node.html">t_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ad890ffb53338be5bb6c68b3b9937dbcf">head</a></td></tr>
<tr class="separator:ad890ffb53338be5bb6c68b3b9937dbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85deb7b8f6de22758684227fbbc1e2d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__node.html">t_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#a85deb7b8f6de22758684227fbbc1e2d8">tail</a></td></tr>
<tr class="separator:a85deb7b8f6de22758684227fbbc1e2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ab64322d2e62d0d7538008048c90fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structt__list.html#ae9ab64322d2e62d0d7538008048c90fe">length</a></td></tr>
<tr class="separator:ae9ab64322d2e62d0d7538008048c90fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0598881e0ae8a82c88a0adb46a96d6"><td class="memItemLeft" align="right" valign="top"><a id="adb0598881e0ae8a82c88a0adb46a96d6"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>print</b> )(struct <a class="el" href="structt__list.html">t_list</a> *list)</td></tr>
<tr class="separator:adb0598881e0ae8a82c88a0adb46a96d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados. </p>
<p>Foi implementado apenas o suficiente para implementar a <a href="https://github.com/y-azvd/calculator/tree/master/C">calculadora em C</a></p>
<p>Na documentação, as funções para lista estão na seção "Membros públicos". Apesar de C não ser uma linguagem que tem suporte para orienteção objeto, as funções foram indicadas com "<code>@memberof <a class="el" href="structt__list.html" title="Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.">t_list</a></code>" para juntar a definição da estrutura de dados <a class="el" href="structt__list.html" title="Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.">t_list</a> e suas funções na mesma página, além de dar a ideia de uma classe e seus métodos.</p>
<dl class="section warning"><dt>Warning</dt><dd>Cabe ressaltar ao usuário que a lista implementada "não sabe" se o espaço de memória apontado <code>node-&gt;data</code> foi alocado dinamicamente ou não. Essa resposabilidade é deixada ao usuário (até porque não sei outra maneira de fazer isso). Esse aviso é ressaltado ao longo da documentação em algumas funções (<a class="el" href="structt__list.html#a002043e4f5f58844e2fafa135691a2e2" title="Remove o primeiro nó da lista e retorna seu dado e libera a memória apontada pelo nó.">remove_head()</a>, <a class="el" href="structt__list.html#a2856474aa1a64f60a649cc55d84e5633" title="Remove o primeiro nó da lista e libera o espaço de memória apontado por data desse nó.">delete_head()</a>, <a class="el" href="structt__list.html#ac3c7cffd8032adc9fbe65be10d8a7e61" title="Remove o nó do topo da pilha.">soft_pop()</a>). Resumidamente, essa biblioteca libera a memória apontada pelo nó, mas a memória apontada por <code>void* data</code> (em <a class="el" href="structt__node.html" title="Nó com ponteiro para dado genérico e com ponteiro para o próximo nó.">t_node</a>) deve ser analisada em cada caso, dependendo da aplicação do usuário, que deve escolher qual função é mais apropriada.</dd></dl>
<p>Essa lista foi testada usando <a href="http://www.valgrind.org/">valgrind</a> e a framework <a href="https://github.com/catchorg/Catch2#whats-the-catch">Catch2</a>. Alguns trechos dos arquivos testes são usados como exemplo, por isso algumas macros do Catch2 estão presentes. Se você não tem familiriadade, cheque a parte <a href="https://github.com/catchorg/Catch2/blob/master/docs/tutorial.md#test-cases-and-sections">Testes e Seções</a>.</p>
<dl class="section see"><dt>See also</dt><dd>Inspirada na lista implemetada em <a href="https://github.com/DevonCrawford/Video-Editing-Automation/blob/master/include/LinkedListAPI.h">link</a>. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae82e5862bbd9ab16a295cd42f7e126c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82e5862bbd9ab16a295cd42f7e126c0">&#9670;&nbsp;</a></span>t_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structt__list.html">t_list</a> <a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definição de t_stack. Tem compatibilidade com <a class="el" href="structt__list.html" title="Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.">t_list</a>. </p>
<p>Honestamente, fiquei com preguiça de colocar esse tipo e suas funções em outro arquivo. São muito poucas. Talvez no futuro eu separe em um arquivo diferente. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf788835199c3cc0faeee83d1a5174f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf788835199c3cc0faeee83d1a5174f0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limpa a lista cujos ponteiros para dado <b>apontam</b> para espaços alocados dinamicamente. </p>
<p>Exemplo: </p><div class="fragment"><div class="line">TEST_CASE(<span class="stringliteral">&quot;multiple insert_head&quot;</span>, <span class="stringliteral">&quot;[list]&quot;</span>) {</div><div class="line">    <span class="keywordtype">int</span>* ptr_int = (<span class="keywordtype">int</span>*) calloc(1, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">    <a class="code" href="structt__list.html">t_list</a>* list = <a class="code" href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec">create_list</a>(<span class="stringliteral">&quot;int&quot;</span>);</div><div class="line"> </div><div class="line">    <span class="keywordtype">int</span> i = 0;</div><div class="line">    <span class="keywordflow">while</span>(i &lt; 3) {</div><div class="line">        *ptr_int = i;</div><div class="line">        <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(list, ptr_int);</div><div class="line">        ptr_int = (<span class="keywordtype">int</span>*) calloc(1, <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));</div><div class="line">        i++;</div><div class="line">    }</div><div class="line"> </div><div class="line">    REQUIRE(list-&gt;<a class="code" href="structt__list.html#ae9ab64322d2e62d0d7538008048c90fe">length</a> == 3);</div><div class="line"> </div><div class="line">    <a class="code" href="structt__list.html#adf788835199c3cc0faeee83d1a5174f0">clear</a>(list);</div><div class="line">    free(list);</div><div class="line">    free(ptr_int);</div><div class="line">}</div></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7d94b3a49834ca1a8077d5b98214fec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d94b3a49834ca1a8077d5b98214fec">&#9670;&nbsp;</a></span>create_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__list.html">t_list</a> * create_list </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cria dinamicamente uma lista. </p>
<p>Além disso, associa as funções <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> - e, futuramente, <a class="el" href="structt__list.html#a0baf4f69baccf00c66d517c87aeea006" title="Não tá pronta. Não Preciso por agora.">compare()</a> - as suas funções com os seus devidos tipos. Por enquanto tem suporte para <code>int</code> e <code>char*</code> .</p>
<dl class="section note"><dt>Note</dt><dd>Para novos tipos de dados, o usuário deve criar a sua própria versão de <a class="el" href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec" title="Cria dinamicamente uma lista.">create_list()</a> e definir, a seu gosto, como associar as funções <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> e <a class="el" href="structt__list.html#a0baf4f69baccf00c66d517c87aeea006" title="Não tá pronta. Não Preciso por agora.">compare()</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Quem chama essa função deve liberar o espaço depois de usá-lo.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_type</td><td>O tipo de dado. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>"int"</code>, <code>"char*"</code> ou <code>"double"</code> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para a lista criada dinamicamente. </dd></dl>

</div>
</div>
<a id="ae0e6488e8c26845bc3ab83a51a20700c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e6488e8c26845bc3ab83a51a20700c">&#9670;&nbsp;</a></span>create_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__node.html">t_node</a> * create_node </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Cria um nó dinamicamente. Normalmente, essa função não é chamada diretamente. É chamada por funções como <a class="el" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1" title="Insere um item no começo da lista.">insert_head()</a> e <a class="el" href="structt__list.html#a87f65f2ab34ec73a894eab5055eb3173" title="Adiciona um nó ao topo da pilha.">push()</a>. Pode ser considerada uma função privada. </p>
<dl class="section note"><dt>Note</dt><dd>Só é preciso se preocupar com vazamento memória se ela for chamada diretamente.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Ponteiro genérico para um tipo de dado.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para o espaço alocado. </dd></dl>

</div>
</div>
<a id="a2856474aa1a64f60a649cc55d84e5633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2856474aa1a64f60a649cc55d84e5633">&#9670;&nbsp;</a></span>delete_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void delete_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove o primeiro nó da lista e libera o espaço de memória apontado por <code>data</code> desse nó. </p>
<dl class="section note"><dt>Note</dt><dd>Deve ser usado <em>apenas</em> em listas cujos dados foram alocado dinamicamente.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"></div><!-- fragment -->
</div>
</div>
<a id="aa2701392584bad966b3ef9afe041bc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2701392584bad966b3ef9afe041bc31">&#9670;&nbsp;</a></span>get_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * get_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna o dado apontado pelo primeiro item da lista. Retorna <code>NULL</code> se a lista estiver vazia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para dado. Retorna <code>NULL</code> se a lista estiver vazia. </dd></dl>

</div>
</div>
<a id="ad083a2ef6a0be599573a1b89a650d7a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad083a2ef6a0be599573a1b89a650d7a9">&#9670;&nbsp;</a></span>get_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * get_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna o dado apontado pelo último item da lista. Retorna <code>NULL</code> se a lista estiver vazia. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para dado. </dd></dl>

</div>
</div>
<a id="a7bc16ed006377d2eb4cd5a7cba829fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc16ed006377d2eb4cd5a7cba829fc1">&#9670;&nbsp;</a></span>insert_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insere um item no começo da lista. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista. </td></tr>
    <tr><td class="paramname">data</td><td>Ponteiro <b>não nulo</b> para dado. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadb8ee7eb28d4b70fd3e61177d6e95b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb8ee7eb28d4b70fd3e61177d6e95b2">&#9670;&nbsp;</a></span>insert_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void insert_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insere um item no final da lista. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista. </td></tr>
    <tr><td class="paramname">data</td><td>Ponteiro <b>não nulo</b> para dado. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3d94767507f4903296df2a3ff20e834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d94767507f4903296df2a3ff20e834">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int is_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checa se a lista está vazia. É o caso de uma lista que acabou de ser criada. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 se está vazio, 0 caso contrário. </dd></dl>

</div>
</div>
<a id="a6acc94726e85208a909776323a41e380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acc94726e85208a909776323a41e380">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * peek </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retorna o ponteiro para o dado do nó no topo da pilha. </p>
<dl class="section warning"><dt>Warning</dt><dd>Se o espaço apontado pelo ponteiro foi alocado dinamicamente, quem chamou essa função é reposável por liberá-lo.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Ponteiro para pilha.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para o dado do nó no topo da pilha. </dd></dl>

</div>
</div>
<a id="a1d3691daad22cb3718822a88ac465ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3691daad22cb3718822a88ac465ca3">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove da pilha o nó no topo da pilha e libera o espaço de memória apontado pelo dado do nó. </p>
<dl class="section note"><dt>Note</dt><dd>Deve ser usado <em>apenas</em> em pilhas cujos dados foram alocados dinamicamente. Semelhante a <a class="el" href="structt__list.html#a002043e4f5f58844e2fafa135691a2e2" title="Remove o primeiro nó da lista e retorna seu dado e libera a memória apontada pelo nó.">remove_head()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Ponteiro para pilha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d0f16dda83dde274b1604e8fe5b5c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0f16dda83dde274b1604e8fe5b5c17">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dados da lista. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acda523ec926b71f0c0ffc6811c0c84d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda523ec926b71f0c0ffc6811c0c84d1">&#9670;&nbsp;</a></span>print_double_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_double_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>double</code>. Pode ser considerada uma função privada. </p>
<dl class="section note"><dt>Note</dt><dd>Não precisa ser chamada diretamente.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11162c6d4ab7eb4745884d7556e64bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11162c6d4ab7eb4745884d7556e64bfa">&#9670;&nbsp;</a></span>print_int_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_int_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>int</code>. Pode ser considerada uma função privada. </p>
<dl class="section note"><dt>Note</dt><dd>Não precisa ser chamada diretamente.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b79392e3a1156b0c077dd6749c19cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b79392e3a1156b0c077dd6749c19cfd">&#9670;&nbsp;</a></span>print_str_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_str_list </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Para fins de depuração, é chamada por <a class="el" href="structt__list.html#a0d0f16dda83dde274b1604e8fe5b5c17" title="Para fins de deparação, imprime a lista na tela. Só deve ser usada quando foi definida o tipo de dado...">print()</a> para listas com tipo de dados <code>char*</code> (ou "<code>string</code>"). Pode ser considerada uma função privada. </p>
<dl class="section note"><dt>Note</dt><dd>Não precisa ser chamada diretamente.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87f65f2ab34ec73a894eab5055eb3173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f65f2ab34ec73a894eab5055eb3173">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adiciona um nó ao topo da pilha. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Ponteiro <b>não nulo</b> para pilha. </td></tr>
    <tr><td class="paramname">data</td><td>Ponteiro <b>não nulo</b> para o dado. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a002043e4f5f58844e2fafa135691a2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002043e4f5f58844e2fafa135691a2e2">&#9670;&nbsp;</a></span>remove_head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * remove_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove o primeiro nó da lista e retorna seu dado e libera a memória apontada pelo nó. </p>
<dl class="section warning"><dt>Warning</dt><dd>Quem chama essa função dever ser o reponsável por liberar memória apontada por data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro <b>não nulo</b> para lista.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>O ponteiro para o primeiro dado da lista.</dd></dl>
<p>Em constraste, ver <a class="el" href="structt__list.html#a2856474aa1a64f60a649cc55d84e5633" title="Remove o primeiro nó da lista e libera o espaço de memória apontado por data desse nó.">delete_head()</a>. </p>

</div>
</div>
<a id="a78961805bdb4393433523317d8163e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78961805bdb4393433523317d8163e20">&#9670;&nbsp;</a></span>soft_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void soft_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html">t_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limpa a lista cujos ponteiros para dado <b>não</b> apontam para espaços alocados dinamicamente. </p>
<p>Nos exemplos abaixo não há chamada de funções como <code>malloc()</code> ou <code>calloc()</code> para alocar memória para os dados a serem armazenados na lista. </p><div class="fragment"><div class="line">    <a class="code" href="structt__list.html">t_list</a>* integers = <a class="code" href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec">create_list</a>(<span class="stringliteral">&quot;int&quot;</span>);</div><div class="line"> </div><div class="line">    <span class="keywordtype">int</span> a = 5;</div><div class="line"> </div><div class="line">    <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(integers, &amp;a);</div><div class="line">    <a class="code" href="structt__list.html#a78961805bdb4393433523317d8163e20">soft_clear</a>(integers);</div><div class="line"> </div><div class="line">    <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(integers, &amp;a);</div><div class="line">    <a class="code" href="structt__list.html#a78961805bdb4393433523317d8163e20">soft_clear</a>(integers);</div><div class="line"> </div><div class="line">    free(integers);</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="structt__list.html">t_list</a>* strings = <a class="code" href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec">create_list</a>(<span class="stringliteral">&quot;char*&quot;</span>);</div><div class="line"> </div><div class="line">    <span class="keywordtype">char</span> str1[] = <span class="stringliteral">&quot;lista&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> str2[] = <span class="stringliteral">&quot;abacaxi&quot;</span>;</div><div class="line">    <span class="keywordtype">char</span> str3[] = <span class="stringliteral">&quot;land rover&quot;</span>;</div><div class="line"> </div><div class="line">    <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(strings, str1);</div><div class="line">    <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(strings, str2);</div><div class="line">    <a class="code" href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">insert_head</a>(strings, str3);</div><div class="line"> </div><div class="line">    <span class="keywordtype">char</span> str[15];</div><div class="line">    strcpy(str, (<span class="keywordtype">char</span>*) <a class="code" href="structt__list.html#aa2701392584bad966b3ef9afe041bc31">get_head</a>(strings));</div><div class="line"> </div><div class="line">    REQUIRE(strcmp(str, <span class="stringliteral">&quot;land rover&quot;</span>) == 0);</div><div class="line"> </div><div class="line">    <a class="code" href="structt__list.html#a78961805bdb4393433523317d8163e20">soft_clear</a>(strings);</div><div class="line">    free(strings);</div></div><!-- fragment --><p> Em contraste, ver <a class="el" href="structt__list.html#adf788835199c3cc0faeee83d1a5174f0" title="Limpa a lista cujos ponteiros para dado apontam para espaços alocados dinamicamente.">clear()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>Ponteiro para lista. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3c7cffd8032adc9fbe65be10d8a7e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c7cffd8032adc9fbe65be10d8a7e61">&#9670;&nbsp;</a></span>soft_pop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * soft_pop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__list.html#ae82e5862bbd9ab16a295cd42f7e126c0">t_stack</a> *&#160;</td>
          <td class="paramname"><em>stack</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove o nó do topo da pilha. </p>
<dl class="section warning"><dt>Warning</dt><dd>Quem chama essa função dever ser o reponsável por liberar memória apontada por data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stack</td><td>Ponteiro para pilha.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Ponteiro para o dado do nó que estava no topo da pilha. Retorna <code>NULL</code> se a pilha está vazia. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad890ffb53338be5bb6c68b3b9937dbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad890ffb53338be5bb6c68b3b9937dbcf">&#9670;&nbsp;</a></span>head</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__node.html">t_node</a>* t_list::head</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ponteiro para o primeiro item. </p>

</div>
</div>
<a id="ae9ab64322d2e62d0d7538008048c90fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9ab64322d2e62d0d7538008048c90fe">&#9670;&nbsp;</a></span>length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int t_list::length</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comprimento da lista. </p>

</div>
</div>
<a id="a85deb7b8f6de22758684227fbbc1e2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85deb7b8f6de22758684227fbbc1e2d8">&#9670;&nbsp;</a></span>tail</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__node.html">t_node</a>* t_list::tail</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ponteiro para o último item. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>lib/list/<a class="el" href="list_8h_source.html">list.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="astructt__list_html_aa7d94b3a49834ca1a8077d5b98214fec"><div class="ttname"><a href="structt__list.html#aa7d94b3a49834ca1a8077d5b98214fec">t_list::create_list</a></div><div class="ttdeci">t_list * create_list(const char *data_type)</div><div class="ttdoc">Cria dinamicamente uma lista.</div><div class="ttdef"><b>Definition:</b> list.c:17</div></div>
<div class="ttc" id="astructt__list_html_adf788835199c3cc0faeee83d1a5174f0"><div class="ttname"><a href="structt__list.html#adf788835199c3cc0faeee83d1a5174f0">t_list::clear</a></div><div class="ttdeci">void clear(t_list *list)</div><div class="ttdoc">Limpa a lista cujos ponteiros para dado apontam para espaços alocados dinamicamente.</div><div class="ttdef"><b>Definition:</b> list.c:130</div></div>
<div class="ttc" id="astructt__list_html_aa2701392584bad966b3ef9afe041bc31"><div class="ttname"><a href="structt__list.html#aa2701392584bad966b3ef9afe041bc31">t_list::get_head</a></div><div class="ttdeci">void * get_head(t_list *list)</div><div class="ttdoc">Retorna o dado apontado pelo primeiro item da lista. Retorna NULL se a lista estiver vazia.</div><div class="ttdef"><b>Definition:</b> list.c:43</div></div>
<div class="ttc" id="astructt__list_html_a78961805bdb4393433523317d8163e20"><div class="ttname"><a href="structt__list.html#a78961805bdb4393433523317d8163e20">t_list::soft_clear</a></div><div class="ttdeci">void soft_clear(t_list *list)</div><div class="ttdoc">Limpa a lista cujos ponteiros para dado não apontam para espaços alocados dinamicamente.</div><div class="ttdef"><b>Definition:</b> list.c:136</div></div>
<div class="ttc" id="astructt__list_html_a7bc16ed006377d2eb4cd5a7cba829fc1"><div class="ttname"><a href="structt__list.html#a7bc16ed006377d2eb4cd5a7cba829fc1">t_list::insert_head</a></div><div class="ttdeci">void insert_head(t_list *list, void *data)</div><div class="ttdoc">Insere um item no começo da lista.</div><div class="ttdef"><b>Definition:</b> list.c:71</div></div>
<div class="ttc" id="astructt__list_html"><div class="ttname"><a href="structt__list.html">t_list</a></div><div class="ttdoc">Lista simplesmente lincada. Está longe de ser uma biblioteca adequada para essa estrutura de dados.</div><div class="ttdef"><b>Definition:</b> list.h:86</div></div>
<div class="ttc" id="astructt__list_html_ae9ab64322d2e62d0d7538008048c90fe"><div class="ttname"><a href="structt__list.html#ae9ab64322d2e62d0d7538008048c90fe">t_list::length</a></div><div class="ttdeci">int length</div><div class="ttdef"><b>Definition:</b> list.h:90</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.16
</small></address>
</body>
</html>
